function [R, sff] = spst_GA(A, I, Red, nsel, options)
%
% [R, sff] = spst_GA(A, I, Red, nsel, options)
%
% Genetic algorithm to optimize a sample of decoys towards a preset value
% of SigmaF
%
%
% Input:    A       Data matrix of actives with rows = compounds,
%                   columns=descriptors
%
%           I       Data matrix of decoys
%
%           Red     Logical array constituting the starting design of
%                   decoys generated by spst_ksnn
%
%           nsel    Number of decoys to select
%
%           options Options struct variable. Default values are indicated
%                   by *asterisks*.
%
%           options.distmode:   *'euc'*, 'city', 'cheby'
%           options.iter:       *20*, any integer
%           options.step:       *0.01*, any decimal
%           options.maxD:       *10*, any integer
%           options.targetG:    *312*, any positive number
%           options.deltaSigmaG *2*, any positive number
%           options.verbose     *true*, boolean
%
% Copyright:        Sebastian Rohrer
%                   University of Braunschweig, Institute of Technology
%                   Department of Pharmaceutical Chemistry
%                   2008

% initialize random numbers generator
% This will generate reproducible results
% If you want true randomness, comment out the following two and the last
% line (reset rand) of the function.
old = rand('state');
rand('state', 0);

% get fitness threshold from options
threshold = options.deltaSigmaG;

% initialize iteration counter
iter = 0;

% set optimization state
optimized = false;

% initialize return values
R = false(size(I,1),1);
sff = zeros(options.iter,1);

% initialize the genepool (all potential decoys)
gp = true(size(I,1),1);

if(options.verbose)
    disp('Calculating NN-Distances...');
end

% remove candidates too far off (farther than maximum NN-Dist in A);
annd = max(nndist(A, A, 1, options.distmode));

% Innd (precalculated NN distances of Inactives) is also used later for 
% fitness calculation see function sigmaF = sigmaF_precompNND (below)
Innd = nndist(I, A, 1, options.distmode);
gp(Innd > annd,1) = false;

% convert logical to indices
gpi = find(gp);

% exit with error, if number of candidates too small
if(size(gpi,1) <= nsel)
    error('spst_Fga: number of candidates too small!');
end

% get reasonable parent from kNN design prduced in previous step
PRI = find(Red);

% generate npop starting individuals by mutating the parent
P = [PRI spst_ga_mutate(PRI, gpi, 0.3, options.npop-1)];

% compute fitness of starting population
% (the smaller, the better!)
if(options.verbose)
    disp('Calculating first fitness vector...');
end
f = spst_Fga_fitness(Innd, P, options);

% sort ascending
[f, ind] = sort(f);
P = P(:,ind);
bestF = f(1);

if(options.verbose)
    % output fitness of the five best individuals
    disp(strcat('Fitness of starting design:', num2str(f(1:5))));
end

if (bestF <= threshold)
        optimized = true;
end

if (options.verbose)
    disp('Start evolution...');
end

no_change_count=0;

while(iter < options.iter && not(optimized) && no_change_count <=3)
    
    
    
    % initialize children
    P2 = zeros(size(P));
    
    % keep the 3 best individuals for the next generation
    P2(:,1:3) = P(:,1:3);
    
    % generate 10 children by mutating best five with low mutation rate
    P2(:,4:13) = spst_ga_mutate(P(:,1:5), gpi, 0.1, 10);
    
    % generate 10 children by mutating best five with high mutation rate
    P2(:,14:23) = spst_ga_mutate(P(:,1:5),gpi, 0.3, 10);
    
    % generate 60 children with very five mutation rate
    P2(:,24:83) = spst_ga_mutate(P(:,1:5),gpi, 0.05, 60);
    
    % generate remaining children by crossover of best 10
    P2(:,84:end)= spst_ga_crossover(P(:,1:10), options.npop-83);
    
    % add a slight level of mutation to a third of the crossover-children
    h = floor(size(P2(:,84:end),2)/3);
    P2(:,84:(83+h)) = spst_ga_mutate(P2(:,84:(83+h)),gpi, 0.02, h);
    
    % fitness of new population (the smaller, the better!)
    f2 = spst_Fga_fitness(Innd, P2, options);

    % sort ascending
    [f2, ind] = sort(f2);
    P2 = P2(:,ind);
    
    % get best fitness
    bestF2 = f2(1);
    % log best fitness value for later analysis
    sff(iter+1,1) = bestF2;
    % set new population
    P = P2;
    
    % exit loop if optimization threshold is reached;
    if (bestF2 < bestF)
        bestF = bestF2;
        no_change_count=0;
    else
        no_change_count=no_change_count+1;
    end
    
    if (options.verbose)
        % output fitness of the five best individuals
        disp(strcat(num2str(iter+1), ' Iterations. Fitness:', num2str(f2(1:5)), ', NoChangeCount:', num2str(no_change_count)));
    end
    
    if (bestF <= threshold)
        optimized = true;
    end
    iter = iter+1;
end

if (options.verbose)
    % output optimization result
    disp(strcat('spst_Fga converged after:', num2str(iter), ' Iterations. With a final fitness of:', num2str(bestF)));
end

R(P(:,1),1) = true;

% reset rand
rand('state', old);

function f = spst_Fga_fitness(Innd, P, options)
%
% This function calculates SigmaF for all individuals of a population and
% compares it to the target value. The difference between SigmaF of each
% individual and the target value (options.targetG) is the fitness of the
% individual.

% initialize
sf = zeros(1, size(P,2));

% loop through individuals and compute sigmaF (see below)
for i=1:size(P,2)
    sf(1,i) = sigmaF_precompNND(Innd(P(:,i),:), options);
end

% fitness = absolute difference 
f = abs(options.targetG - sf);


function sigmaF = sigmaF_precompNND(nndist, options)
%
% By using a precomputed vector of the distance of each decoy to its
% nearest neighbor active, this function calculates F and sigmaF for a
% sample of decoys much faster than spst_F.

% determine dataset sizes
[m n] = size(nndist);

% Initialize x-Axis
x = ones(m,1)*(0:options.step:options.maxD);

% Inflate the distance vector to a matrix the same size as x
d = nndist*ones(1,size(x,2));

% Calculate F
nn = d < x;
num_set = sum(nn);
F= num_set./m;

% Calculate and return SigmaF
sigmaF = sum(F);


function C = spst_ga_mutate(P, gpi, mutRate, numC)
%
% This function mutates a sample of decoys (an individual) by replacing
% part of it by random decoys selected from the genepool (all other
% potential decoys).

% determine population size
[m n] = size(P);

% if we want to produce more children than parents
if (numC>n)
    % repeat P until there are more than enough parents
    size_factor = ceil(numC/n);
    P = repmat(P,1,size_factor);
    % randomly select enough parents
    r = randperm(size_factor*n);
    P=P(:,r(1:numC));
end

% if we want to produce less children than parents
if(numC<n)
    r = randperm(n);
    P = P(:,r(1:numC));
end

C = zeros(m,numC);
for i=1:numC
    % disallow decoys already present in the current set
    gpii = setdiff(gpi, P(:,i));
    
    % mutate according to mutation rate
    num_keep = floor(m*(1-mutRate));
    num_get = m-num_keep;
    
    % randomly select the decoys to keep
    r1 = randperm(m);
    k = P(r1(1:num_keep),i);
    % fill up other places with randomly chosen decoys from the pool.
    r2 = randperm(size(gpii,1));
    g = gpii(r2(1:num_get));
    
    C(:,i) = [k; g];
end


function C = spst_ga_crossover(P, numC)
%
% This function generates a new sample of decoys (child chromosome) by 
% randomly combining two other samples of decoys (parent chromosomes). 

[m n] = size(P);
C = zeros(m,numC);

% if we want to produce more children than parents
if (numC>n)
    % repeat P until there are more than enough parents
    size_factor = ceil(numC/n);
    P = repmat(P,1,size_factor);
    % randomly select enough parents
    r = randperm(size_factor*n);
    P=P(:,r(1:numC));
end

% generate random pairs for crossover.
p = zeros(2,numC);
p(1,:) = randperm(numC);
p(2,:) = randperm(numC);

% do actual crossover
for j=1:numC
    % combine both parents
    sex = unique([P(:,p(1,j));P(:,p(2,j))]);
    % mix randomly
    r = randperm(size(sex,1));
    sex = sex(r);
    
    % create the child
    C(:,j) = sex(1:m,1);
end
        
