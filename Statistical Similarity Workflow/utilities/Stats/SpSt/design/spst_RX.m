function [R, sgs] = spst_RX(A, Red, nsel, options)
%
% [R, sff] = spst_RX(A, Red, nsel, options)
%
% Row-exchange algorithm to optimize a sample of actives towards a preset value
% of SigmaG
%
%
% Input:    A       Data matrix of actives with rows = compounds,
%                   columns=descriptors
%
%           Red     Logical array constituting the starting design of
%                   actives generated by spst_ksnn
%
%           nsel    Number of actives to select
%
%           options Options struct variable. Default values are indicated
%                   by *asterisks*.
%
%           options.distmode:   *'euc'*, 'city', 'cheby'
%           options.iter:       *20*, any integer
%           options.step:       *0.008*, any positive number
%           options.maxD:       *4*, any positive number
%           options.targetG:    *312*, any positive number
%           options.deltaSigmaG *2*, any positive number
%           options.r           *0.8*, any positive number
%           options.verbose     *true*, boolean
%
% Copyright:        Sebastian Rohrer
%                   University of Braunschweig, Institute of Technology
%                   Department of Pharmaceutical Chemistry
%                   2008


% initialize random numbers generator
old = rand('state');
rand('state', 0);

% get dataset size
[m n] = size(A);

% initialize return values
R = false(m,1);
sgs = zeros(options.iter,2);

% initialize design variables
d = zeros(nsel,1);
sG = options.targetG;
% Starting design from previous step (Kennard-Stone)
d(:,1) = find(Red);

% get stopping criterion
threshold=options.deltaSigmaG;

% initiate tabu matrix
% 0 means tabu for next iteration
tabu = ones(m,1);
tabu(d,1) = 0;

% initialize loop variables and off we go...
iter = 1;
has_changed = 1;
is_optimized = 0;

while(iter <= options.iter & has_changed == 1 & is_optimized == 0)
    has_changed = 0;
    
    % loop over all actives in the currently selected set
    for i=1:nsel 
        
        % compute of the set d(SigmaG) before exchange
        G = spst_G(A(d,:), [], options);
        G = sum(G(:,2));
        old_DsG = abs(G - sG);
        
        % throw out row i without using setdiff (terribly slow)
        d2 = [d(1:(i-1),1);d((i+1):end)];
        
        % find rows not yet in set
        nd = find(tabu);
        
        % calculate nearest neighbor distances
        nndistance = nndist(A(nd,:), A(d,:), 1, options.distmode);
        
        % remove candidates below similarity cutoff and outliers
        nd = nd(nndistance >= options.r);
                
        if(nd)  % proceed only if there are selectable candidates left
            
            % compute sG for exchange
            sgg = zeros(size(nd,1),1);
            for j=1:size(nd,1)
                gg = spst_G(A([d2;nd(j,1)],:), [], options);
                sgg(j,1) = sum(gg(:,2));
            end

            % the row that produces the lowest difference from sG is the best for exchange 
            dsgg = abs(sG-sgg);

            % Now we want the point creates the smallest differences from
            % sG
            [mdsgg, ind] = min(dsgg);
            new_DsG = dsgg(ind,1);
            new_sG = sgg(ind,1);
            new_member = nd(ind,1);


            % make exchange only if DsG decreases 
            if (old_DsG - new_DsG > 0)
                tabu(d(i,1),1) = 1;             % allow replaced candidate to replace the other rows
                d(i,1) = new_member;            % replace old candidate by new one
                tabu(new_member,1) = 0;         % disallow new_member for following replacements
                sgs(iter,1) = new_DsG;          % record old and new DsG
                sgs(iter,2) = new_sG;
                has_changed = 1;                % indicate that the current iteration has changed the set           
                
                if(new_DsG <= threshold)        % if optimization criterion is reached exit the loop
                    is_optimized = 1;
                    break;
                end
            else                                % if the exchange is not favorable (and therefore not made)...
                sgs(iter,1) = old_DsG;          % record DsG
                sgs(iter,2) = G;
            end
        else
            sgs(iter,1) = old_DsG;         % record DsG
            sgs(iter,2) = G;
        end
        
    end
    iter = iter + 1;                       % increment interation counter
end

if (options.verbose)
    disp(strcat('Optimized after:', num2str(iter), ' Iterations. delta(SigmaG)=', num2str(sgs(iter-1,1)), ' SigmaG=', num2str(sgs(iter-1,2))));
end

if(iter == options.iter && options.verbose)
    disp('Maximum Iterations reached');
end

d = sort(d,'ascend');

R(d,1) = true;
rand('state', old);